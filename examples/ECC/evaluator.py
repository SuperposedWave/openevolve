"""
Evaluator for a fixed binary linear code evolved by OpenEvolve.

The evolved program must define:
    run_code() -> G
where G is a binary generator matrix of shape (k, n).
"""

import numpy as np
import time
import os
import subprocess
import tempfile
import traceback
import sys
import pickle

TARGET_K = 10
TARGET_N = 35


# =========================
# Subprocess runner
# =========================

class TimeoutError(Exception):
    pass


def run_with_timeout(program_path, timeout_seconds=60):
    """
    Run program.run_code() in a separate process.
    """
    with tempfile.NamedTemporaryFile(suffix=".py", delete=False) as f:
        script = f"""
import sys, os, pickle, traceback
import numpy as np

sys.path.insert(0, os.path.dirname('{program_path}'))

try:
    import importlib.util
    spec = importlib.util.spec_from_file_location("program", '{program_path}')
    program = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(program)

    G = program.run_code()

    with open('{f.name}.out', 'wb') as g:
        pickle.dump({{'G': G}}, g)

except Exception as e:
    traceback.print_exc()
    with open('{f.name}.out', 'wb') as g:
        pickle.dump({{'error': str(e)}}, g)
"""
        f.write(script.encode())
        tmp_path = f.name

    out_path = tmp_path + ".out"

    try:
        proc = subprocess.Popen(
            [sys.executable, tmp_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        proc.communicate(timeout=timeout_seconds)

        if not os.path.exists(out_path):
            raise RuntimeError("No output produced")

        with open(out_path, "rb") as g:
            result = pickle.load(g)

        if "error" in result:
            raise RuntimeError(result["error"])

        return np.array(result["G"], dtype=np.uint8)

    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)
        if os.path.exists(out_path):
            os.unlink(out_path)


# =========================
# GF(2) utilities
# =========================

def gf2_rank(G: np.ndarray) -> int:
    """
    Rank of a binary matrix over GF(2).
    """
    G = G.copy().astype(np.uint8)
    rows, cols = G.shape
    r = 0

    for c in range(cols):
        pivot = None
        for i in range(r, rows):
            if G[i, c]:
                pivot = i
                break
        if pivot is None:
            continue

        G[[r, pivot]] = G[[pivot, r]]
        for i in range(rows):
            if i != r and G[i, c]:
                G[i] ^= G[r]

        r += 1
        if r == rows:
            break

    return r


def min_distance_exact(G: np.ndarray) -> int:
    """
    Exact minimum Hamming distance by enumerating all non-zero messages.
    Complexity: O(2^k), OK for moderate k.
    """
    k, n = G.shape
    best = n

    for x in range(1, 1 << k):
        msg = np.array([(x >> i) & 1 for i in range(k)], dtype=np.uint8)
        cw = msg @ G % 2
        w = int(np.sum(cw))
        if w < best:
            best = w
            if best <= 1:
                return best

    return best


# =========================
# Spectrum utilities
# =========================

def weight_spectrum_exact(G: np.ndarray) -> np.ndarray:
    """
    Exact weight distribution A_w for a binary linear code generated by G.

    Returns:
        A: length-(n+1) array where A[w] is the number of codewords of weight w.

    Notes:
        - Includes the all-zero codeword (weight 0).
        - Complexity: O(2^k * (k+n)), OK for moderate k.
    """
    k, n = G.shape
    A = np.zeros(n + 1, dtype=np.int64)

    # Enumerate all messages (including 0) to count weights of codewords.
    for x in range(0, 1 << k):
        msg = np.array([(x >> i) & 1 for i in range(k)], dtype=np.uint8)
        cw = msg @ G % 2
        w = int(np.sum(cw))
        A[w] += 1

    return A


def spectrum_tiebreak_score(A: np.ndarray, d: int, window: int = 8) -> float:
    """
    Produce a small tie-break score from the low-weight tail of the spectrum.

    For fixed (n,k) and fixed d, we prefer codes with fewer low-weight codewords.

    We compute the normalized mass in weights d..d+window and convert it to a score
    in [0,1], where larger is better.

    Args:
        A: weight spectrum array (length n+1)
        d: minimum distance
        window: how many weights above d to include

    Returns:
        score in [0,1] (larger is better)
    """
    n = len(A) - 1
    total_nonzero = int(np.sum(A)) - 1  # exclude all-zero
    if total_nonzero <= 0:
        return 0.0

    hi = min(n, d + window)
    low_mass = int(np.sum(A[d:hi + 1])) / float(total_nonzero)
    # smaller low_mass is better
    return float(max(0.0, min(1.0, 1.0 - low_mass)))


# =========================
# Validation
# =========================

def validate_generator(G: np.ndarray):
    if not isinstance(G, np.ndarray):
        return False, "G is not a numpy array"

    if G.ndim != 2:
        return False, "G is not 2D"

    if not np.isin(G, [0, 1]).all():
        return False, "G has entries not in {0,1}"

    k, n = G.shape
    if k != TARGET_K or n != TARGET_N:
        return False, f"G is not of shape ({k=}, {n=})"

    if gf2_rank(G) != k:
        return False, "G is not full rank over GF(2)"

    return True, None


# =========================
# Main evaluation
# =========================

def evaluate(program_path):
    """
    Evaluate a candidate generator matrix.

    Returns a dict with:
        d, target_ratio, spectrum_score, Ad, Ad1, validity, combined_score, eval_time
    """
    start = time.time()

    try:
        G = run_with_timeout(program_path, timeout_seconds=600)

        valid, err = validate_generator(G)
        if not valid:
            print("Invalid code:", err)
            return _invalid(start)

        k, n = G.shape

        # Compute minimum distance
        d = min_distance_exact(G)

        # Compute exact weight spectrum for finer-grained tie-breaking
        A = weight_spectrum_exact(G)

        # Singleton bound as normalization target
        d_max = n - k + 1
        ratio = d / d_max if d_max > 0 else 0.0

        # Spectrum-based tie-breaker (must be small so it never dominates changes in d)
        spec_score = spectrum_tiebreak_score(A, d=int(d), window=8)
        # Keep epsilon well below the typical step size of ratio (1/d_max)
        epsilon = 1e-3
        combined = float(ratio) + epsilon * float(spec_score)

        Ad = int(A[int(d)]) if 0 <= int(d) <= n else 0
        Ad1 = int(A[int(d) + 1]) if int(d) + 1 <= n else 0

        return {
            "d": float(d),
            "target_ratio": float(ratio),
            "spectrum_score": float(spec_score),
            "Ad": float(Ad),
            "Ad1": float(Ad1),
            "validity": 1.0,
            "combined_score": combined,
            "eval_time": float(time.time() - start),
        }

    except TimeoutError:
        print("Evaluation timed out")
        return _invalid(start)

    except Exception as e:
        print("Evaluation failed:", e)
        traceback.print_exc()
        return _invalid(start)


def _invalid(start):
    return {
        "d": 0.0,
        "target_ratio": 0.0,
        "validity": 0.0,
        "combined_score": 0.0,
        "eval_time": float(time.time() - start),
    }


# =========================
# Cascade hooks
# =========================

def evaluate_stage1(program_path):
    """
    Stage 1: only check legality (fast).
    """
    try:
        G = run_with_timeout(program_path, timeout_seconds=120)
        valid, _ = validate_generator(G)
        if valid:
            return {"validity": 1.0, "combined_score": 0.5}
        else:
            return {"validity": 0.0, "combined_score": 0.0}
    except Exception:
        return {"validity": 0.0, "combined_score": 0.0}


def evaluate_stage2(program_path):
    """
    Stage 2: full evaluation.
    """
    return evaluate(program_path)
